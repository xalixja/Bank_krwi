\documentclass[12pt,a4paper]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{array}
\usepackage{xcolor}
\usepackage{url}
\usepackage{listings}

% Konfiguracja wyświetlania kodu SQL
\lstset{
    language=SQL,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    frame=single,
    showstringspaces=false,
    inputencoding=utf8,
    extendedchars=true,
    literate={ą}{{\k{a}}}1 {ć}{{\'c}}1 {ę}{{\k{e}}}1 {ł}{{\l{}}}1 {ń}{{\'n}}1 {ó}{{\'o}}1 {ś}{{\'s}}1 {ż}{{\.z}}1 {ź}{{\'z}}1 {Ą}{{\k{A}}}1 {Ć}{{\'C}}1 {Ę}{{\k{E}}}1 {Ł}{{\L{}}}1 {Ń}{{\'N}}1 {Ó}{{\'O}}1 {Ś}{{\'S}}1 {Ż}{{\.Z}}1 {Ź}{{\'Z}}1
}

\geometry{margin=2.5cm}

\title{Dokumentacja projektu \\ \textbf{Bank Krwi}}
\author{Alicja Borek}
\date{Semestr zimowy 2025/2026}

\begin{document}

\maketitle

% ============================================================
\section{Projekt koncepcji i założenia}

\subsection{Zdefiniowanie tematu projektu}
Celem projektu jest stworzenie kompletnego systemu informatycznego wspierającego działanie banku krwi. Aplikacja ma na celu cyfryzację procesów związanych z oddawaniem krwi, zarządzaniem magazynem oraz dystrybucją krwi do szpitali.

\textbf{Główne cele i zadania:}
\begin{itemize}
    \item Rejestracja i ewidencja dawców krwi.
    \item Obsługa procesu zgłaszania chęci oddania krwi (weryfikacja terminów).
    \item Rejestrowanie faktycznych oddań oraz wyników badań laboratoryjnych.
    \item Zarządzanie zapotrzebowaniami zgłaszanymi przez jednostki medyczne (szpitale).
    \item Monitorowanie stanu magazynowego krwi z uwzględnieniem daty ważności.
    \item Kontrola dostępu do panelów w zależności od roli użytkownika.
\end{itemize}

\subsection{Analiza wymagań użytkownika}
W systemie wyróżniono cztery role użytkowników, z których każda posiada dedykowane funkcjonalności:

\begin{itemize}
    \item \textbf{Dawca}: Może rejestrować się w systemie, zarządzać danymi osobowymi, przeglądać historię oddań, wyniki badań oraz zgłaszać chęć oddania krwi (zapisywać się na termin).
    \item \textbf{Pracownik banku krwi}: Posiada uprawnienia do wprowadzania nowych oddań, wpisywania wyników badań (HIV, HCV itp.), zarządzania stanem magazynowym oraz realizowania zapotrzebowań szpitali.
    \item \textbf{Szpital}: Konto instytucjonalne, które umożliwia zgłaszanie zapotrzebowania na konkretną grupę krwi i śledzenie statusu realizacji (oczekujące/zrealizowane).
    \item \textbf{Administrator}: Zarządza użytkownikami systemu (zakładanie kont pracowniczych i szpitalnych oraz dawcó)w, posiada dostęp do pełnych statystyk systemu.
\end{itemize}

\subsection{Zaprojektowanie funkcji}
Baza danych realizuje następujące funkcje podstawowe:
\begin{itemize}
    \item \textbf{Przechowywanie danych}: Bezpieczne składowanie haseł (szyfrowanie `pgcrypto`) i danych wrażliwych.
    \item \textbf{Logika biznesowa (Triggers)}: Automatyczne wyliczanie daty ważności krwi (35 dni), blokowanie zbyt częstych oddań (56 dni przerwy), zmiana statusu krwi.
    \item \textbf{Raportowanie (Views)}: Generowanie widoków dla magazynu, historii badań oraz statystyk zapotrzebowań.
\end{itemize}

% ============================================================
\section{Projekt diagramów (konceptualny)}

\subsection{Budowa i analiza diagramu przepływu danych (DFD)}
Analiza przepływu danych (Data Flow Diagram - DFD) na poziomie 1 obrazuje logiczne przetwarzanie informacji w systemie Banku Krwi. Model ten identyfikuje źródła danych, procesy transformujące te dane oraz miejsca ich przechowywania.

\subsubsection{Elementy sterujące przepływem}
Przepływ danych w systemie nie jest liniowy, lecz sterowany przez zdefiniowane reguły biznesowe zaimplementowane w warstwie aplikacji (Flask) oraz bazy danych (Triggery SQL). Główne elementy sterujące to:
\begin{itemize}
    \item \textbf{Autoryzacja ról}: Mechanizm \texttt{@login\_required} we Flasku decyduje, czy użytkownik ma prawo uruchomić dany proces (np. tylko Szpital może wysłać zapotrzebowanie).
    \item \textbf{Walidacja czasowa}: Wyzwalacze w bazie danych (np. \texttt{blokuj\_wczesne\_zgloszenie}) sterują przepływem, odrzucając próby wprowadzenia błędnych danych.
    \item \textbf{Wyniki badań}: Warunek logiczny w procesie przetwarzania oddania – wynik pozytywny automatycznie zmienia ścieżkę przepływu na "Utylizacja/Blokada", zamiast "Magazyn dostępny".
\end{itemize}

\subsubsection{Specyfikacja przepływów (Wejścia i Wyjścia)}
System podzielono na trzy główne procesy przetwarzania danych:

\begin{enumerate}
    \item \textbf{Proces 1.0: Obsługa Dawcy i Zgłoszeń}
    \begin{itemize}
        \item \textbf{Wejście}: Dane osobowe dawcy, deklarowana data wizyty.
        \item \textbf{Operacje}: Weryfikacja historii w tabeli \texttt{Oddania\_krwi}, sprawdzenie swoich zgłoszeń, rejestracja w tabeli \texttt{Zgloszenia}.
        \item \textbf{Wyjście}: Zarejestrowanie terminu wizyty ze statusem oczekujące lub komunikat błędu (blokada).
        \item \textbf{Magazyn danych}: Tabela \texttt{Dawcy}, Tabela \texttt{Zgloszenia}.
    \end{itemize}

    \item \textbf{Proces 2.0: Przetwarzanie Donacji i Badań}
    \begin{itemize}
        \item \textbf{Wejście}: Fizyczna jednostka krwi (ilość ml), PESEL dawcy, wyniki badań laboratoryjnych.
        \item \textbf{Operacje}: Rejestracja oddania przez Pracownika, przypisanie daty ważności (Trigger +35 dni), walidacja wyników badań (Trigger \texttt{oznacz\_odrzucone\_badanie}).
        \item \textbf{Wyjście}: Jednostka krwi o statusie \texttt{'dostepne'} gotowa do wydania lub \texttt{'odrzucone'} niezdatna do wydania.
        \item \textbf{Magazyn danych}: Tabela \texttt{Oddania\_krwi}, Tabela \texttt{Badania}.
    \end{itemize}

    \item \textbf{Proces 3.0: Dystrybucja i Obsługa Szpitali}
    \begin{itemize}
        \item \textbf{Wejście}: Zapotrzebowanie szpitala (Grupa krwi, Rh, ilość).
        \item \textbf{Operacje}: Algorytm FIFO (First-In-First-Out) wyszukujący najstarsze pasujące jednostki krwi, aktualizacja stanów magazynowych (zmniejszenie \texttt{ilosc\_pozostala}), zmiana statusu na \texttt{'zrealizowane'}.
        \item \textbf{Wyjście}: Raport wydania krwi, aktualizacja panelu "Komu pomogłem?"(\texttt{Dawca\_Szpital}).
        \item \textbf{Magazyn danych}: Tabela \texttt{Zapotrzebowania}, Tabela \texttt{Oddanie\_Zapotrzebowanie}.
    \end{itemize}
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{dfd_level1.png}
    \caption{Diagram przepływu danych (DFD) poziomu 1 dla systemu Banku Krwi.}
\end{figure}

\subsection{Zdefiniowanie encji i atrybutów}
W systemie zdefiniowano następujące klasy encji:

\begin{enumerate}
    \item \textbf{Użytkownicy} (\texttt{Uzytkownicy}): Encja nadrzędna przechowująca dane logowania dla wszystkich ról systemowych.
    \begin{itemize}
        \item Atrybuty: \texttt{login}, \texttt{haslo} (hash), \texttt{rola} (ENUM: ADMIN, PRACOWNIK, SZPITAL, DAWCA), \texttt{data\_rejestracji}.
    \end{itemize}
    
    \item \textbf{Dawcy} (\texttt{Dawcy}): Rozszerzenie konta użytkownika o dane medyczne.
    \begin{itemize}
        \item Atrybuty: \texttt{imie}, \texttt{nazwisko}, \texttt{pesel} (unikalny), \texttt{grupa\_krwi}, \texttt{rh}, \texttt{kontakt}, \texttt{cel\_ml}.
    \end{itemize}

    \item \textbf{Pracownicy Banku} (\texttt{Pracownicy\_banku}):
    \begin{itemize}
        \item Atrybuty: \texttt{imie}, \texttt{nazwisko}, \texttt{stanowisko} (lekarz/laborant).
    \end{itemize}

    \item \textbf{Szpitale} (\texttt{Szpitale}): Placówki zamawiające krew.
    \begin{itemize}
        \item Atrybuty: \texttt{nazwa}, \texttt{adres}.
    \end{itemize}

    \item \textbf{Zgłoszenia} (\texttt{Zgloszenia}): Rezerwacje terminów wizyt przez dawców.
    \begin{itemize}
        \item Atrybuty: \texttt{data\_zgloszenia}, \texttt{status} (oczekujące/zrealizowane).
    \end{itemize}

    \item \textbf{Oddania Krwi} (\texttt{Oddania\_krwi}): Fizyczne jednostki krwi w magazynie.
    \begin{itemize}
        \item Atrybuty: \texttt{data\_oddania}, \texttt{ilosc\_ml}, \texttt{data\_waznosci}, \texttt{status} (dostępne, zużyte, przeterminowane, odrzucone_badanie), \texttt{ilosc\_pozostala}.
    \end{itemize}
    
    \item \textbf{Badania} (\texttt{Badania}): Wyniki testów wirusologicznych dla oddań.
    \begin{itemize}
        \item Atrybuty: \texttt{rodzaj\_badania} (HIV, HCV...), \texttt{wynik}, \texttt{data\_badania}.
    \end{itemize}

    \item \textbf{Zapotrzebowania} (\texttt{Zapotrzebowania}): Zamówienia składane przez szpitale.
    \begin{itemize}
        \item Atrybuty: \texttt{grupa\_krwi}, \texttt{rh}, \texttt{ilosc\_ml}, \texttt{status}, \texttt{data\_wydania}.
    \end{itemize}
\end{enumerate}

\subsection{Zaprojektowanie relacji pomiędzy encjami}


\subsubsection{Klucze i powiązania (Relacje)}
System opiera się na relacjach realizowanych poprzez klucze obce (\textit{Foreign Keys}):

\begin{itemize}
    \item \textbf{Relacja 1:1 (Dziedziczenie ról)}: Tabele \texttt{Dawcy}, \texttt{Pracownicy\_banku} oraz \texttt{Szpitale} są powiązane z tabelą \texttt{Uzytkownicy} poprzez klucz obcy \texttt{id\_uzytkownika}, który jest jednocześnie kluczem unikalnym. Pozwala to na oddzielenie danych autoryzacyjnych od danych osobowych.
    
    \item \textbf{Relacja 1:N (Jeden do wielu)}:
    \begin{itemize}
        \item Jeden \textbf{Dawca} może mieć wiele \textbf{Oddań} oraz \textbf{Zgłoszeń}.
        \item Jedno \textbf{Oddanie} może mieć przypisane wiele \textbf{Badań}.
        \item Jeden \textbf{Szpital} może złożyć wiele \textbf{Zapotrzebowań}.
    \end{itemize}
\end{itemize}

\subsubsection{Eliminacja powiązań wiele-do-wielu (Tabele asocjacyjne)}
Zidentyfikowano obszary, w których zachodziła relacja N:M, i rozwiązano je poprzez wprowadzenie tabel pośredniczących:

\begin{itemize}
    \item \textbf{Realizacja zamówień (\texttt{Oddanie\_Zapotrzebowanie})}: 
    Pojedyncze zapotrzebowanie (np. 1000 ml) może wymagać krwi z kilku różnych oddań (np. 2 worki po 450 ml + 100 ml z trzeciego). Z kolei jedno oddanie może zostać rozdzielone na kilka mniejszych zapotrzebowań. Tabela ta łączy \texttt{id\_oddania} z \texttt{id\_zapotrzebowania}, przechowując informację o konkretnej ilości przekazanej krwi (\texttt{ilosc\_ml}).
    
    \item \textbf{Historia przepływu (\texttt{Dawca\_Szpital})}: 
    Tabela służąca do celów raportowych i śledzenia drogi "Komu pomogłem?". Łączy Dawcę ze Szpitalem poprzez konkretne Oddanie, umożliwiając Dawcy sprawdzenie, do jakiej placówki trafiła jego krew.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{erd_diagram.png}
    \caption{Diagram związków encji (ERD) obrazujący strukturę bazy danych Banku Krwi.}
    \label{fig:erd}
\end{figure}

% ============================================================
\section{Projekt logiczny}

\subsection{Projektowanie tabel (Struktura SQL)}
Poniżej przedstawiono kod SQL tworzący główne struktury danych. Wykorzystano typy danych dopasowane do domeny (np. `VARCHAR(11)` dla PESEL, `CHECK` dla grup krwi).

\subsubsection{Tabela Użytkownicy}
\begin{lstlisting}
create table Uzytkownicy (
    id_uzytkownika serial primary key,
    login varchar(50) not null unique,
    haslo varchar(200) not null,
    rola varchar(20) check (rola in ('ADMIN','PRACOWNIK','SZPITAL','DAWCA')),
    data_rejestracji date default current_date
);
\end{lstlisting}

\subsubsection{Tabela Dawcy}
\begin{lstlisting}
create table Dawcy (
    id_dawcy serial primary key,
    imie varchar(30) not null,
    nazwisko varchar(30) not null,
    pesel varchar(11) unique not null,
    grupa_krwi varchar(2) check (grupa_krwi in ('A','B','AB','0')),
    rh varchar(1) check (rh in ('+','-')),
    kontakt varchar(9),
    id_uzytkownika int unique references Uzytkownicy(id_uzytkownika),
    cel_ml int
);
\end{lstlisting}

\subsubsection{Tabela Pracownicy banku}
\begin{lstlisting}
create table Pracownicy_banku (
    id_pracownika serial primary key,
    imie varchar(30) not null,
    nazwisko varchar(30) not null,
    stanowisko varchar(20) check (stanowisko in ('lekarz','laborant')),
    id_uzytkownika int unique references Uzytkownicy(id_uzytkownika)
);
\end{lstlisting}

\subsubsection{Tabela Szpitale}
\begin{lstlisting}
create table Szpitale (
    id_szpitala serial primary key,
    nazwa varchar(100) not null,
    adres varchar(200),
    id_uzytkownika int unique references Uzytkownicy(id_uzytkownika)
);
\end{lstlisting}

\subsubsection{Tabela Zgłoszenia}
\begin{lstlisting}
create table Zgloszenia (
    id_zgloszenia serial primary key,
    id_dawcy int references Dawcy(id_dawcy),
    data_zgloszenia date default current_date,
    status varchar(20) check (status in ('oczekujace','zrealizowane'))
);

\end{lstlisting}

\subsubsection{Tabela Oddania Krwi}
\begin{lstlisting}
create table Oddania_krwi (
    id_oddania serial primary key,
    data_oddania date not null,
    ilosc_ml int check (ilosc_ml between 200 and 500),
    data_waznosci date,
    id_dawcy int references Dawcy(id_dawcy),
    id_zgloszenia int references Zgloszenia(id_zgloszenia),
    id_pracownika int references Pracownicy_banku(id_pracownika),
    ilosc_pozostala int default 0,
    status varchar(20) default 'dostepne' check (status in('dostepne','zuzyte','przeterminowane','odrzucone_badanie'))
);
\end{lstlisting}

\subsubsection{Tabela Zapotrzebowania}
\begin{lstlisting}
create table Zapotrzebowania (
    id_zapotrzebowania serial primary key,
    id_szpitala int references Szpitale(id_szpitala),
    grupa_krwi varchar(2) check (grupa_krwi in ('A','B','AB','0')),
    rh varchar(1) check (rh in ('+','-')),
    ilosc_ml int check (ilosc_ml > 0),
    status varchar(20) check (status in ('oczekujace','zrealizowane')),
    data_wydania date,
    id_pracownika int references Pracownicy_banku(id_pracownika)
);

\end{lstlisting}

\subsubsection{Tabela Badania}
\begin{lstlisting}
create table Badania (
    id_badania serial primary key,
    id_oddania int references Oddania_krwi(id_oddania),
    rodzaj_badania varchar(50) not null,
    wynik varchar(50) check (wynik in('pozytywny', 'negatywny')),
    data_badania date,
    id_pracownika int references Pracownicy_banku(id_pracownika)
);
\end{lstlisting}

\subsection{Słowniki danych}
W bazie zastosowano ograniczenia (`CHECK constraints`), które pełnią rolę słowników danych, zapewniając integralność informacji.

\begin{longtable}{|p{4cm}|p{4cm}|p{6cm}|}
\hline
\textbf{Atrybut} & \textbf{Tabela} & \textbf{Dozwolone wartości / Ograniczenia} \\ \hline
rola & Uzytkownicy & 'ADMIN', 'PRACOWNIK', 'SZPITAL', 'DAWCA' \\ \hline
grupa\_krwi & Dawcy, Zapotrzebowania & 'A', 'B', 'AB', '0' \\ \hline
rh & Dawcy, Zapotrzebowania & '+', '-' \\ \hline
stanowisko & Pracownicy\_banku & 'lekarz', 'laborant' \\ \hline
status & Zgloszenia & 'oczekujace', 'zrealizowane' \\ \hline
status & Oddania\_krwi & 'dostepne', 'zuzyte', 'przeterminowane', 'odrzucone\_badanie' \\ \hline
ilosc\_ml & Oddania\_krwi & Przedział 200 - 500 \\ \hline
ilosc\_ml & Zapotrzebowania, Oddanie\_Zapotrzebowanie & Większe od 0 \\ \hline
\end{longtable}

\subsection{Normalizacja tabel}
Projekt bazy danych został poddany procesowi normalizacji, aby uniknąć redundancji i anomalii.

\begin{itemize}
    \item \textbf{1NF (Pierwsza postać normalna)}: Wszystkie atrybuty są atomowe (np. imię i nazwisko są w osobnych kolumnach, adres szpitala jest pojedynczym ciągiem znaków traktowanym jako całość w tym kontekście).
    \item \textbf{2NF (Druga postać normalna)}: Każda tabela posiada klucz główny, a wszystkie atrybuty niekluczowe zależą od całego klucza. W tabelach asocjacyjnych (np. `Oddanie\_Zapotrzebowanie`) atrybuty takie jak `ilosc\_ml` zależą od obu kluczy obcych tworzących klucz główny.
    \item \textbf{3NF (Trzecia postać normalna)}: Usunięto zależności przechodnie. Na przykład dane szczegółowe o dawcy nie są powielane w tabeli `Oddania\_krwi` – znajduje się tam tylko klucz obcy `id\_dawcy`. Adres szpitala znajduje się w tabeli `Szpitale`, a nie w `Zapotrzebowania`.
\end{itemize}

\subsection{Denormalizacja}
W celu optymalizacji zapytań raportowych wprowadzono elementy denormalizacji w widokach, jednak struktura fizyczna tabel pozostaje znormalizowana. Wyjątkiem optymalizacyjnym jest kolumna `ilosc\_pozostala` w tabeli `Oddania\_krwi`, która jest aktualizowana na bieżąco, aby uniknąć każdorazowego sumowania wydań przy sprawdzaniu stanu magazynu.

\subsection{Zaprojektowanie operacji na danych - Widoki}
Zdefiniowano widoki (Views) w celu uproszczenia warstwy logiki aplikacji i realizacji najczęstsze operacje wyszukiwania:

\textbf{Stan magazynu:}
\begin{lstlisting}
CREATE OR REPLACE VIEW widok_magazyn AS
SELECT
    o.id_oddania,
    d.imie || ' ' || d.nazwisko AS dawca,
    d.grupa_krwi,
    d.rh,
    o.ilosc_ml AS ilosc_poczatkowa,
    o.ilosc_pozostala,
    o.status,
    o.data_waznosci
FROM oddania_krwi o
JOIN dawcy d ON o.id_dawcy = d.id_dawcy;
\end{lstlisting}

\textbf{Szczegóły zapotrzebowań:}
\begin{lstlisting}
create view Widok_status_zapotrzebowan as
select z.id_zapotrzebowania,
       s.nazwa as szpital,
       z.grupa_krwi,
       z.rh,
       z.ilosc_ml,
       z.status,
       z.data_wydania,
       p.imie || ' ' || p.nazwisko as pracownik
from Zapotrzebowania z
join Szpitale s on z.id_szpitala = s.id_szpitala
left join Pracownicy_banku p on z.id_pracownika = p.id_pracownika;
\end{lstlisting}

\textbf{Historia badań:}
\begin{lstlisting}
CREATE OR REPLACE VIEW widok_historia_badania AS
SELECT 
    b.id_badania,
    o.id_oddania,
    d.imie || ' ' || d.nazwisko AS dawca,
    b.rodzaj_badania,
    b.wynik,
    b.data_badania,
    p.imie || ' ' || p.nazwisko AS pracownik,
    p.id_pracownika
FROM Badania b
JOIN Oddania_krwi o ON b.id_oddania = o.id_oddania
JOIN Dawcy d ON o.id_dawcy = d.id_dawcy
JOIN Pracownicy_banku p ON b.id_pracownika = p.id_pracownika;
\end{lstlisting}

\textbf{"Komu pomogłem?":}
\begin{lstlisting}
create view Widok_dawcy_szpitale as
SELECT 
    ds.id_dawcy,
    d.imie || ' ' || d.nazwisko AS dawca,
    s.nazwa AS szpital,
    ds.data_przekazania,
    o.ilosc_ml AS ilosc_oddana
FROM dawca_szpital ds
JOIN dawcy d ON ds.id_dawcy = d.id_dawcy
JOIN szpitale s ON ds.id_szpitala = s.id_szpitala
JOIN oddania_krwi o ON ds.id_oddania = o.id_oddania;
\end{lstlisting}

\textbf{Aktywność pracownika:}
\begin{lstlisting}
create view Widok_pracownicy_aktywnosc as
select p.id_pracownika,
       p.imie || ' ' || p.nazwisko as pracownik,
       p.stanowisko,
       count(distinct o.id_oddania) as liczba_oddan,
       count(distinct b.id_badania) as liczba_badan,
       count(distinct z.id_zapotrzebowania) as liczba_zapotrzebowan
from Pracownicy_banku p
left join Oddania_krwi o on p.id_pracownika = o.id_pracownika
left join Badania b on p.id_pracownika = b.id_pracownika
left join Zapotrzebowania z on p.id_pracownika = z.id_pracownika
group by p.id_pracownika, p.imie, p.nazwisko, p.stanowisko;
\end{lstlisting}

\textbf{Średnia ilość oddanej krwi:}
\begin{lstlisting}
CREATE OR REPLACE VIEW widok_srednia_ilosc AS
SELECT ROUND(AVG(o.ilosc_ml), 2) AS srednia_ml
FROM oddania_krwi o;
\end{lstlisting}

\textbf{Daty oddania krwi:}
\begin{lstlisting}
create view Widok_dat_oddan as
select id_dawcy, 
		min(data_oddania) as pierwsze_oddanie,
       max(data_oddania) as ostatnie_oddanie
from Oddania_krwi
group by 1;
\end{lstlisting}

\textbf{Statystyki badań:}
\begin{lstlisting}
create view Widok_statystyki_badan as
select 
    count(*) filter (where wynik = 'negatywny') as negatywne,
    count(*) filter (where wynik = 'pozytywny') as pozytywne
from Badania;
\end{lstlisting}

\textbf{Stan magazynu:}
\begin{lstlisting}
CREATE OR REPLACE VIEW widok_stan_krwi AS
SELECT
    d.grupa_krwi,
    d.rh,
    SUM(o.ilosc_pozostala) AS dostepne_ml
FROM oddania_krwi o
JOIN dawcy d ON o.id_dawcy = d.id_dawcy
WHERE o.status = 'dostepne' AND o.ilosc_pozostala > 0
GROUP BY d.grupa_krwi, d.rh;
\end{lstlisting}

\textbf{Suma oddanej krwi danego dawcy:}
\begin{lstlisting}
CREATE VIEW widok_suma_ml AS
SELECT 
    id_dawcy,
    SUM(ilosc_ml) AS suma_ml
FROM oddania_krwi
GROUP BY id_dawcy;
\end{lstlisting}

\textbf{Logistyka oddawanej krwi do konkretnych zapotrzebowań:}
\begin{lstlisting}
CREATE OR REPLACE VIEW widok_powiazania AS
SELECT 
    oz.id_oddania,
    o.data_oddania,
    o.ilosc_ml AS ilosc_oddana,
    oz.ilosc_ml AS ilosc_przekazana,
    oz.id_zapotrzebowania,
    z.data_wydania AS data_zapotrzebowania,
    s.nazwa AS szpital
FROM oddanie_zapotrzebowanie oz
JOIN oddania_krwi o ON oz.id_oddania = o.id_oddania
JOIN zapotrzebowania z ON oz.id_zapotrzebowania = z.id_zapotrzebowania
JOIN szpitale s ON z.id_szpitala = s.id_szpitala
ORDER BY oz.id_zapotrzebowania DESC;
\end{lstlisting}

\textbf{Raportowanie dużych zapotrzebowań (Agregacja)}\\
Widok ten wykorzystuje klauzulę \texttt{HAVING}, aby filtrować dane już po pogrupowaniu. Służy do identyfikacji szpitali zgłaszających zapotrzebowanie powyżej 1000 ml na daną grupę krwi.

\begin{lstlisting}
create view Widok_zapotrzebowania_duze as
select s.nazwa as szpital,
       z.grupa_krwi,
       z.rh,
       sum(z.ilosc_ml) as suma_ml
from Zapotrzebowania z
join Szpitale s on z.id_szpitala = s.id_szpitala
group by s.nazwa, z.grupa_krwi, z.rh
having sum(z.ilosc_ml) > 1000;
\end{lstlisting}

\subsection{Logika biznesowa - Wyzwalacze (triggery):}

\textbf{Automatycznie wpisuje bieżącą datę wydania przy zmianie statusu zapotrzebowania na 'zrealizowane':}
\begin{lstlisting}
create or replace function set_data_wydania()
returns trigger as $$
begin
    if NEW.status = 'zrealizowane' and NEW.data_wydania is null then
        NEW.data_wydania := current_date;
    end if;
    return NEW;
end;
$$ language plpgsql;

create trigger trg_set_data_wydania
before insert or update on Zapotrzebowania
for each row
execute function set_data_wydania();
\end{lstlisting}

\textbf{Automatyczne ustawienie daty ważności (35 dni):}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION ustaw_date_waznosci()
RETURNS trigger AS $$
BEGIN
    -- ZAWSZE ustawiamy datę ważności na 35 dni od daty oddania
    NEW.data_waznosci := NEW.data_oddania + INTERVAL '35 days';
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_oddania_data_waznosci
BEFORE INSERT OR UPDATE ON oddania_krwi
FOR EACH ROW
EXECUTE FUNCTION ustaw_date_waznosci();
\end{lstlisting}

\textbf{Zmienia status krwi na 'przeterminowane', jeśli minęła jej data ważności:}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION oznacz_przeterminowane()
RETURNS trigger AS $$
BEGIN
    IF NEW.data_waznosci < CURRENT_DATE THEN
        NEW.status := 'przeterminowane';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_przeterminowane
BEFORE UPDATE OR INSERT ON oddania_krwi
FOR EACH ROW
EXECUTE FUNCTION oznacz_przeterminowane();
\end{lstlisting}

\textbf{Automatycznie zmienia status oddania na 'odrzucone', jeśli wynik badania jest pozytywny:}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION oznacz_odrzucone_badanie()
RETURNS trigger AS $$
BEGIN
    -- Jeśli wynik badania jest pozytywny -> odrzucamy jednostkę
    IF NEW.wynik = 'pozytywny' THEN
        UPDATE oddania_krwi
        SET status = 'odrzucone_badanie'
        WHERE id_oddania = NEW.id_oddania;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_odrzucone_badanie
AFTER INSERT OR UPDATE ON badania
FOR EACH ROW
EXECUTE FUNCTION oznacz_odrzucone_badanie();
\end{lstlisting}

\textbf{Po dodaniu oddania automatycznie zmienia status powiązanego zgłoszenia na 'zrealizowane':}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION przyjmij_najstarsze_zgloszenie()
RETURNS trigger AS $$
BEGIN
    -- Aktualizujemy najstarsze oczekujące zgłoszenie danego dawcy
    UPDATE zgloszenia
    SET status = 'zrealizowane'
    WHERE id_zgloszenia = (
        SELECT id_zgloszenia
        FROM zgloszenia
        WHERE id_dawcy = NEW.id_dawcy
          AND status = 'oczekujace'
        ORDER BY data_zgloszenia ASC
        LIMIT 1
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_przyjmij_zgloszenie
AFTER INSERT ON oddania_krwi
FOR EACH ROW
EXECUTE FUNCTION przyjmij_najstarsze_zgloszenie();
\end{lstlisting}

\textbf{Blokuje możliwość dodania nowego zgłoszenia, jeśli dawca ma już jedno oczekujące:}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION blokuj_wiele_zgloszen()
RETURNS trigger AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM zgloszenia
        WHERE id_dawcy = NEW.id_dawcy
          AND status = 'oczekujace'
    ) THEN
        RAISE EXCEPTION 'Dawca ma już aktywne zgłoszenie.';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_1_blokuj_wiele_zgloszen
BEFORE INSERT ON zgloszenia
FOR EACH ROW
EXECUTE FUNCTION blokuj_wiele_zgloszen();
\end{lstlisting}

\textbf{Blokada zbyt częstych oddań (56 dni przerwy)}
Funkcja sprawdza datę ostatniego oddania dla danego dawcy przed dodaniem nowego zgłoszenia.
\begin{lstlisting}
CREATE OR REPLACE FUNCTION blokuj_wczesne_zgloszenie()
RETURNS trigger AS $$
DECLARE
    ostatnie DATE;
BEGIN
    SELECT data_oddania INTO ostatnie
    FROM oddania_krwi
    WHERE id_dawcy = NEW.id_dawcy
    ORDER BY data_oddania DESC
    LIMIT 1;

    IF ostatnie IS NOT NULL AND NEW.data_zgloszenia < ostatnie + INTERVAL '56 days' THEN
        RAISE EXCEPTION 'Możesz oddać krew dopiero po %', ostatnie + INTERVAL '56 days';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_2_blokuj_wczesne_oddanie
BEFORE INSERT ON zgloszenia
FOR EACH ROW
EXECUTE FUNCTION blokuj_wczesne_zgloszenie();
\end{lstlisting}

\textbf{Uniemożliwia rejestrację oddania krwi, jeśli od poprzedniego nie minęło 56 dni:}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION blokuj_wczesne_oddanie()
RETURNS trigger AS $$
DECLARE
    ostatnie DATE;
BEGIN
    SELECT data_oddania INTO ostatnie
    FROM oddania_krwi
    WHERE id_dawcy = NEW.id_dawcy
    ORDER BY data_oddania DESC
    LIMIT 1;

    IF ostatnie IS NOT NULL AND NEW.data_oddania < ostatnie + INTERVAL '56 days' THEN
        RAISE EXCEPTION 'Możesz oddać krew dopiero po %', ostatnie + INTERVAL '56 days';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_blokuj_wczesne_oddanie
BEFORE INSERT ON oddania_krwi
FOR EACH ROW
EXECUTE FUNCTION blokuj_wczesne_oddanie();
\end{lstlisting}

\textbf{Tworzy wpis w historii powiązań dawcy ze szpitalem w momencie przekazania krwi:}
\begin{lstlisting}
CREATE OR REPLACE FUNCTION automatyczny_dawca_szpital()
RETURNS trigger AS $$
DECLARE
    v_id_dawcy INT;
    v_id_szpitala INT;
BEGIN
    -- Pobieramy ID dawcy na podstawie oddania
    SELECT id_dawcy INTO v_id_dawcy 
    FROM oddania_krwi 
    WHERE id_oddania = NEW.id_oddania;

    -- Pobieramy ID szpitala na podstawie zapotrzebowania
    SELECT id_szpitala INTO v_id_szpitala 
    FROM zapotrzebowania 
    WHERE id_zapotrzebowania = NEW.id_zapotrzebowania;

    -- Wstawiamy rekord do tabeli Dawca_Szpital
    -- (Używamy ON CONFLICT DO NOTHING, żeby nie wywaliło błędu, jak już coś tam jest)
    INSERT INTO Dawca_Szpital (id_dawcy, id_szpitala, id_oddania, data_przekazania)
    VALUES (v_id_dawcy, v_id_szpitala, NEW.id_oddania, CURRENT_DATE)
    ON CONFLICT DO NOTHING;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_auto_dawca_szpital
AFTER INSERT ON Oddanie_Zapotrzebowanie
FOR EACH ROW
EXECUTE FUNCTION automatyczny_dawca_szpital();
\end{lstlisting}


% ============================================================
\section{Projekt funkcjonalny}

\subsection{Interfejsy do prezentacji i edycji danych}
System został zaprojektowany jako aplikacja webowa. Struktura formularzy obejmuje:
\begin{itemize}
    \item \textbf{Formularz logowania}: Wspólny dla wszystkich ról, dodatkowo dla dawców opcja rejestracji.
    \item \textbf{Panel Dawcy}: Tabela z historią oddań i badań, formularz "Dodaj zgłoszenie".
    \item \textbf{Panel Pracownika}: Formularze "Dodaj oddanie", "Wprowadź wynik badania", tabela zarządzania zapotrzebowaniami oraz magazynem krwi.
    \item \textbf{Panel Szpitala}: Formularz "Zgłoś zapotrzebowanie".
\end{itemize}

\subsection{Wizualizacja danych (Raporty)}
Baza danych dostarcza gotowe zestawy danych do raportów poprzez widoki, które wspierają podejmowanie decyzji logistycznych::
\begin{itemize}
    \item \texttt{widok\_pracownicy\_aktywnosc}: Raport wydajności pracowników (liczba obsłużonych oddań, badań i zapotrzebowań).
    \item \texttt{widok\_zapotrzebowania\_duze}: Raport dla szpitali zgłaszających duże zapotrzebowanie ($>1000$ml). Występuje w formie alertu na panelu pracownika.
    \item \texttt{widok\_statystyki\_badan}: Zestawienie wyników pozytywnych i negatywnych (np. HIV/HCV).
\end{itemize}

\subsection{Panel sterowania aplikacji}
Aplikacja posiada główny Dashboard, który dynamicznie zmienia zawartość w zależności od roli zalogowanego użytkownika (`id\_uzytkownika` powiązane z tabelami ról).

\subsection{Makropolecenia i automatyzacja procesów}

W systemie zaimplementowano szereg makropoleceń w formie funkcji logiki biznesowej (backend Python/Flask), które agregują złożone operacje na bazie danych pod jedną akcją użytkownika.

\begin{itemize}
    \item \textbf{Makropolecenie: Automatyczna Realizacja Zapotrzebowania (Algorytm FIFO)} \\
    \textit{Lokalizacja w kodzie:} \texttt{/pracownik/zapotrzebowania/zrealizuj/<int:id\_zapotrzebowania>} \\
    \textbf{Działanie:} Po wywołaniu funkcji system automatycznie weryfikuje stan magazynowy, pobiera najstarsze dostępne jednostki krwi (zgodnie z zasadą FIFO), dzieli je na wymagane porcje, aktualizuje stany magazynowe (zmniejsza ilość lub oznacza jako ,,zużyte'') oraz zmienia status zapotrzebowania na ,,zrealizowane'' wraz z ustawieniem daty wydania.

    \item \textbf{Makropolecenie: Rejestracja Konta Zintegrowana z Profilem Dawcy} \\
    \textit{Lokalizacja w kodzie:} \texttt{/register} \\
    \textbf{Działanie:} System w ramach jednej transakcji atomowej weryfikuje unikalność loginu, tworzy konto użytkownika z zaszyfrowanym hasłem (bcrypt), tworzy powiązany profil dawcy z danymi osobowymi oraz automatycznie loguje użytkownika, inicjując sesję.

    \item \textbf{Makropolecenie: Rejestracja Donacji na podstawie PESEL} \\
    \textit{Lokalizacja w kodzie:} \texttt{/pracownik/oddania} (metoda POST) \\
    \textbf{Działanie:} Pracownik wprowadza jedynie numer PESEL i ilość pobranej krwi. Makropolecenie wyszukuje ID dawcy w bazie, waliduje poprawność daty (blokada dat z przyszłości) i rejestruje nowe oddanie, tworząc relację między dawcą, pracownikiem a jednostką krwi.

    \item \textbf{Makropolecenie: Walidacja i Rejestracja Badania} \\
    \textit{Lokalizacja w kodzie:} \texttt{/pracownik/badania} (metoda POST) \\
    \textbf{Działanie:} System przyjmuje wyniki badań laboratoryjnych, weryfikuje logiczną poprawność daty i zapisuje wynik w historii. Operacja ta jest ściśle powiązana z triggerami bazy danych, co może skutkować automatyczną dyskwalifikacją jednostki krwi (zmiana statusu na ,,odrzucone'').
\end{itemize}

% ============================================================
\section{Dokumentacja}

\subsection{Wprowadzanie danych}
Dane są wprowadzane do systemu na trzy sposoby:
\begin{enumerate}
    \item \textbf{Manualnie}: Poprzez formularze aplikacji webowej (rejestracja, zgłoszenia).
    \item \textbf{Automatycznie (Triggery)}: System sam uzupełnia pola takie jak `data\_rejestracji` (DEFAULT current\_date), `data\_waznosci` czy `status`.
    \item \textbf{Skrypt inicjalizujący}: Baza została zasilona danymi testowymi przy użyciu instrukcji `INSERT` zawartych w pliku `bank\_krwi.sql` (m.in. utworzenie kont użytkowników).
\end{enumerate}

\subsection{Dokumentacja użytkownika (Instrukcja)}

\textbf{Krótka ścieżka obsługi dla Dawcy:}
\begin{enumerate}
    \item Wejdź na stronę główną i wybierz "Zarejestruj się" lub "Zaloguj się" jeśli masz konto.
    \item Po zalogowaniu wybierz zakładkę "Zgłoszenia i historia".
    \item Kliknij "Wyślij zgłoszenie" – system sprawdzi, czy upłynął wymagany czas od ostatniego oddania.
    \item Po wizycie w punkcie pobrań, historia oddania pojawi się w tej samej zakładce co powyżej.
\end{enumerate}

\textbf{Krótka ścieżka obsługi dla Pracownika:}
\begin{enumerate}
    \item Zaloguj się na konto pracownicze i sprawdź Panel (system wyświetli alerty o dużych zapotrzebowaniach).
    \item Aby przyjąć krew: wejdź w zakładkę "Oddania", wyszukaj dawcę po peselu i dodaj nowe oddanie (system automatycznie ustawi datę ważności).
    \item Aby uzupełnić wyniki: przejdź do zakładki "Badania", wybierz oddanie i wprowadź wynik (np. HIV/HCV) – w przypadku wyniku pozytywnego system zablokuje jednostkę.
    \item Aby wydać krew: w sekcji "Zapotrzebowania" sprawdź listę oczekujących zamówień i po wydaniu krwi zmień status na "Zrealizowane".
\end{enumerate}

\textbf{Krótka ścieżka obsługi dla Szpitala:}
\begin{enumerate}
    \item Zaloguj się danymi placówki medycznej.
    \item Wybierz opcję "Zgłoś zapotrzebowanie".
    \item Wypełnij formularz określając grupę krwi, czynnik Rh oraz ilość (ml).
    \item Śledź status swojego zamówienia w tabeli "Moje zapotrzebowania" – gdy pracownik banku wyda krew, status zmieni się z "Oczekujące" na "Zrealizowane".
\end{enumerate}

\subsection{Opracowanie dokumentacji technicznej}
Projekt zrealizowano w architekturze klient-serwer, uruchamianej w środowisku lokalnym (localhost).
\begin{itemize}
    \item \textbf{Baza danych}: PostgreSQL 14+. Wykorzystano rozszerzenie `pgcrypto` do bezpiecznego haszowania haseł.
    \item \textbf{Backend}: Python (Flask) łączący się z bazą przez sterownik `psycopg2`.
\item \textbf{Struktura plików}:
    \begin{itemize}
        \item \texttt{bank\_krwi.sql} – kompletny skrypt inicjalizujący bazę danych. Zawiera definicje DDL (tworzenie tabel, relacji, indeksów), implementację logiki biznesowej po stronie serwera SQL (funkcje PL/pgSQL, wyzwalacze/triggery), definicje widoków raportowych oraz instrukcje DML zasilające system danymi startowym.
        
        \item \texttt{db/connection.py} – moduł odpowiedzialny za nawiązywanie połączenia z bazą danych. Wykorzystuje bibliotekę \texttt{psycopg2} do komunikacji z PostgreSQL. Centralizuje konfigurację parametrów połączenia (host, port, poświadczenia) oraz automatycznie ustawia ścieżkę wyszukiwania (\texttt{search\_path}) na schemat \texttt{bank\_krwi}, co upraszcza zapytania SQL w aplikacji.
        
        \item \texttt{app.py} – główny plik wykonywalny aplikacji oparty na frameworku Flask. Pełni rolę kontrolera: obsługuje routing (ścieżki URL), zarządza sesjami użytkowników, realizuje mechanizmy autoryzacji (sprawdzanie ról) oraz pośredniczy w wymianie danych między formularzami a bazą danych.
        
        \item \texttt{templates/} – katalog zawierający szablony widoków HTML. Wykorzystuje silnik szablonów Jinja2 do dynamicznego renderowania danych pobranych z bazy (np. tabele wyników, alerty). Warstwa prezentacji jest zintegrowana z frameworkiem Bootstrap 5, co zapewnia responsywność interfejsu.
        
        \item \texttt{static/style.css} – arkusz stylów definiujący unikalną szatę graficzną aplikacji. Rozszerza standardowe komponenty frameworka Bootstrap (takie jak tabele i przyciski), nadpisując ich zmienne i wprowadzając dedykowany motyw kolorystyczny oparty na głębokiej czerwieni (\texttt{\#8a0303}), co zapewnia interfejsowi wygląd adekwatny do tematyki Banku Krwi.
    \end{itemize}
\end{itemize}

\subsection{Wykaz literatury}
\begin{itemize}
    \item Dokumentacja PostgreSQL: \url{https://www.postgresql.org/docs/}
    \item Dokumentacja Flask: \url{https://flask.palletsprojects.com/}
    \item Materiały z wykładów przedmiotu "Bazy Danych I".
    \item Dokumentacja Bootstrap 5: \url{https://getbootstrap.com/}
    \item Wikipedia:
    \url{https://pl.wikipedia.org/wiki/Posta%C4%87_normalna_(bazy_danych)}
\end{itemize}

\end{document}
